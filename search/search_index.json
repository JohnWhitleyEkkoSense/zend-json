{
    "docs": [
        {
            "location": "/",
            "text": "zend-json\n\n\n\n\n\n\nZend\\Json\n provides convenience methods for serializing native PHP to JSON and\ndecoding JSON to native PHP. For more information on JSON, visit the JSON\n\nproject site\n.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-json/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-json/",
            "title": "zend-json"
        },
        {
            "location": "/#zend-json",
            "text": "Zend\\Json  provides convenience methods for serializing native PHP to JSON and\ndecoding JSON to native PHP. For more information on JSON, visit the JSON project site .   File issues at https://github.com/zendframework/zend-json/issues  Documentation is at https://docs.zendframework.com/zend-json/",
            "title": "zend-json"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-json provides convenience methods for serializing native PHP to JSON and\ndecoding JSON to native PHP. For more information on JSON, \nvisit the JSON\nproject site\n.\n\n\nJSON, JavaScript Object Notation, can be used for data interchange between\nJavaScript and other languages. Since JSON can be directly evaluated by\nJavaScript, it is a more efficient and lightweight format than XML for\nexchanging data with JavaScript clients.",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-json provides convenience methods for serializing native PHP to JSON and\ndecoding JSON to native PHP. For more information on JSON,  visit the JSON\nproject site .  JSON, JavaScript Object Notation, can be used for data interchange between\nJavaScript and other languages. Since JSON can be directly evaluated by\nJavaScript, it is a more efficient and lightweight format than XML for\nexchanging data with JavaScript clients.",
            "title": "Introduction"
        },
        {
            "location": "/basics/",
            "text": "Basic Usage\n\n\nUsage of zend-json involves using two public static methods:\n\nZend\\Json\\Json::encode()\n and \nZend\\Json\\Json::decode()\n.\n\n\n// Decode a JSON value to PHP:\n$phpNative = Zend\\Json\\Json::decode($encodedValue);\n\n// Encode a PHP value to JSON:\n$json = Zend\\Json\\Json::encode($phpNative);\n\n\n\n\n\next/json\n\n\nBy default, the above two calls will proxy to the \njson_decode()\n and\n\njson_encode()\n functions of \next/json\n, which is bundled in default\ninstallations of PHP. Using zend-json, however, ensures that the functionality\nworks regardless of whether or not the extension is available. Additionally,\nthe component provides some features not found in \next/json\n, such as\nencoding native JSON expressions, communicating class inheritance, and\ncustomizations around pretty printing.\n\n\n\n\nPretty-printing JSON\n\n\nSometimes, it may be hard to explore JSON data generated by\n\nZend\\Json\\Json::encode()\n, since it has no spacing or indentation. In order to\nmake it easier, \nZend\\Json\\Json\n allows you to pretty-print JSON data in the\nhuman-readable format with \nZend\\Json\\Json::prettyPrint()\n.\n\n\n// Encode it to return to the client:\n$json = Zend\\Json\\Json::encode($phpNative);\nif ($debug) {\n    echo Zend\\Json\\Json::prettyPrint($json, array('indent' => ' '));\n}\n\n\n\nThe second, optional, argument to \nZend\\Json\\Json::prettyPrint()\n is an option\narray. Option \nindent\n allows providing an indentation string; by default, it\nuses four spaces.",
            "title": "Basic Usage"
        },
        {
            "location": "/basics/#basic-usage",
            "text": "Usage of zend-json involves using two public static methods: Zend\\Json\\Json::encode()  and  Zend\\Json\\Json::decode() .  // Decode a JSON value to PHP:\n$phpNative = Zend\\Json\\Json::decode($encodedValue);\n\n// Encode a PHP value to JSON:\n$json = Zend\\Json\\Json::encode($phpNative);",
            "title": "Basic Usage"
        },
        {
            "location": "/basics/#extjson",
            "text": "By default, the above two calls will proxy to the  json_decode()  and json_encode()  functions of  ext/json , which is bundled in default\ninstallations of PHP. Using zend-json, however, ensures that the functionality\nworks regardless of whether or not the extension is available. Additionally,\nthe component provides some features not found in  ext/json , such as\nencoding native JSON expressions, communicating class inheritance, and\ncustomizations around pretty printing.",
            "title": "ext/json"
        },
        {
            "location": "/basics/#pretty-printing-json",
            "text": "Sometimes, it may be hard to explore JSON data generated by Zend\\Json\\Json::encode() , since it has no spacing or indentation. In order to\nmake it easier,  Zend\\Json\\Json  allows you to pretty-print JSON data in the\nhuman-readable format with  Zend\\Json\\Json::prettyPrint() .  // Encode it to return to the client:\n$json = Zend\\Json\\Json::encode($phpNative);\nif ($debug) {\n    echo Zend\\Json\\Json::prettyPrint($json, array('indent' => ' '));\n}  The second, optional, argument to  Zend\\Json\\Json::prettyPrint()  is an option\narray. Option  indent  allows providing an indentation string; by default, it\nuses four spaces.",
            "title": "Pretty-printing JSON"
        },
        {
            "location": "/advanced/",
            "text": "Advanced Usage\n\n\nJSON Objects\n\n\nWhen encoding PHP objects as JSON, all public properties of that object will be\nencoded in a JSON object.\n\n\nJSON does not allow object references, so care should be taken not to encode\nobjects with recursive references. If you have issues with recursion,\n\nZend\\Json\\Json::encode()\n and \nZend\\Json\\Encoder::encode()\n each allow an\noptional second parameter to check for recursion; if an object is serialized\ntwice, an exception will be thrown.\n\n\nDecoding JSON objects poses additional difficulty, however, since JavaScript\nobjects correspond most closely to PHP's associative array. Some suggest that a\nclass identifier should be passed, and an object instance of that class should\nbe created and populated with the key/value pairs of the JSON object; others\nfeel this could pose a substantial security risk.\n\n\nBy default, \nZend\\Json\\Json\n will decode JSON objects as \nstdClass\n objects.\nHowever, if you desire an associative array returned, you can request it using\nthe second argument to \ndecode()\n:\n\n\n// Decode JSON objects as PHP array\n$phpNative = Zend\\Json\\Json::decode($encodedValue, Zend\\Json\\Json::TYPE_ARRAY);\n\n\n\nAny objects thus decoded are returned as associative arrays with keys and values\ncorresponding to the key/value pairs in the JSON notation.\n\n\nThe recommendation of Zend Framework is that the individual developer should\ndecide how to decode JSON objects. If an object of a specified type should be\ncreated, it can be created in the developer code and populated with the values\ndecoded using zend-json.\n\n\nEncoding PHP objects\n\n\nIf you are encoding PHP objects, the default encoding mechanism can only\naccess public properties of these objects. When a method \ntoJson()\n is\nimplemented on an object to encode, \nZend\\Json\\Json\n calls this method and\nexpects the object to return a JSON representation of its internal state.\n\n\nZend\\Json\\Json\n can encode PHP objects recursively but does not do so by\ndefault. This can be enabled by passing \ntrue\n as the second argument to\n\nZend\\Json\\Json::encode()\n.\n\n\n// Encode PHP object recursively\n$jsonObject = Zend\\Json\\Json::encode($data, true);\n\n\n\nWhen doing recursive encoding of objects, as JSON does not support cycles, a\n\nZend\\Json\\Exception\\RecursionException\n will be thrown. If you wish, you can\nsilence these exceptions by passing the \nsilenceCyclicalExceptions\n option:\n\n\n$jsonObject = Zend\\Json\\Json::encode(\n    $data,\n    true,\n    ['silenceCyclicalExceptions' => true]\n);\n\n\n\nInternal Encoder/Decoder\n\n\nZend\\Json\n has two different modes depending if ext/json is enabled in your PHP\ninstallation or not. If \next/json\n is installed, zend-json will use the\n\njson_encode()\n and \njson_decode()\n functions for encoding and decoding JSON. If\n\next/json\n is not installed, a Zend Framework implementation in PHP code is used\nfor en/decoding. This is considerably slower than using the PHP extension, but\nbehaves exactly the same.\n\n\nSometimes you might want to use the zend-json encoder/decoder even if you have\n\next/json\n installed. You can achieve this by calling:\n\n\nZend\\Json\\Json::$useBuiltinEncoderDecoder = true;\n\n\n\nJSON Expressions\n\n\nJavaScript makes heavy use of anonymous function callbacks, which can be saved\nwithin JSON object variables. They only work if not returned inside double\nquotes, which zend-json implements by default. With the Expression support for\nzend-json, you can encode JSON objects with valid JavaScript callbacks.\nThis works when either \njson_encode()\n or the internal encoder is used.\n\n\nA JavaScript callback is represented using the \nZend\\Json\\Expr\n object. It\nimplements the value object pattern and is immutable. You can set the JavaScript\nexpression as the first constructor argument. By default\n\nZend\\Json\\Json::encode()\n does not encode JavaScript callbacks; you have to\npass the option \nenableJsonExprFinder\n and set it to \nTRUE\n when calling the\n\nencode()\n method. If enabled, the expression support works for all nested\nexpressions in large object structures.\n\n\nAs an example:\n\n\n$data = [\n    'onClick' => new Zend\\Json\\Expr(\n        'function() {'\n        . 'alert(\"I am a valid JavaScript callback created by Zend\\\\Json\");\n        . '}'\n    ),\n    'other' => 'no expression',\n];\n$jsonObjectWithExpression = Zend\\Json\\Json::encode(\n    $data,\n    false,\n    ['enableJsonExprFinder' => true]\n);",
            "title": "Advanced Usage"
        },
        {
            "location": "/advanced/#advanced-usage",
            "text": "",
            "title": "Advanced Usage"
        },
        {
            "location": "/advanced/#json-objects",
            "text": "When encoding PHP objects as JSON, all public properties of that object will be\nencoded in a JSON object.  JSON does not allow object references, so care should be taken not to encode\nobjects with recursive references. If you have issues with recursion, Zend\\Json\\Json::encode()  and  Zend\\Json\\Encoder::encode()  each allow an\noptional second parameter to check for recursion; if an object is serialized\ntwice, an exception will be thrown.  Decoding JSON objects poses additional difficulty, however, since JavaScript\nobjects correspond most closely to PHP's associative array. Some suggest that a\nclass identifier should be passed, and an object instance of that class should\nbe created and populated with the key/value pairs of the JSON object; others\nfeel this could pose a substantial security risk.  By default,  Zend\\Json\\Json  will decode JSON objects as  stdClass  objects.\nHowever, if you desire an associative array returned, you can request it using\nthe second argument to  decode() :  // Decode JSON objects as PHP array\n$phpNative = Zend\\Json\\Json::decode($encodedValue, Zend\\Json\\Json::TYPE_ARRAY);  Any objects thus decoded are returned as associative arrays with keys and values\ncorresponding to the key/value pairs in the JSON notation.  The recommendation of Zend Framework is that the individual developer should\ndecide how to decode JSON objects. If an object of a specified type should be\ncreated, it can be created in the developer code and populated with the values\ndecoded using zend-json.",
            "title": "JSON Objects"
        },
        {
            "location": "/advanced/#encoding-php-objects",
            "text": "If you are encoding PHP objects, the default encoding mechanism can only\naccess public properties of these objects. When a method  toJson()  is\nimplemented on an object to encode,  Zend\\Json\\Json  calls this method and\nexpects the object to return a JSON representation of its internal state.  Zend\\Json\\Json  can encode PHP objects recursively but does not do so by\ndefault. This can be enabled by passing  true  as the second argument to Zend\\Json\\Json::encode() .  // Encode PHP object recursively\n$jsonObject = Zend\\Json\\Json::encode($data, true);  When doing recursive encoding of objects, as JSON does not support cycles, a Zend\\Json\\Exception\\RecursionException  will be thrown. If you wish, you can\nsilence these exceptions by passing the  silenceCyclicalExceptions  option:  $jsonObject = Zend\\Json\\Json::encode(\n    $data,\n    true,\n    ['silenceCyclicalExceptions' => true]\n);",
            "title": "Encoding PHP objects"
        },
        {
            "location": "/advanced/#internal-encoderdecoder",
            "text": "Zend\\Json  has two different modes depending if ext/json is enabled in your PHP\ninstallation or not. If  ext/json  is installed, zend-json will use the json_encode()  and  json_decode()  functions for encoding and decoding JSON. If ext/json  is not installed, a Zend Framework implementation in PHP code is used\nfor en/decoding. This is considerably slower than using the PHP extension, but\nbehaves exactly the same.  Sometimes you might want to use the zend-json encoder/decoder even if you have ext/json  installed. You can achieve this by calling:  Zend\\Json\\Json::$useBuiltinEncoderDecoder = true;",
            "title": "Internal Encoder/Decoder"
        },
        {
            "location": "/advanced/#json-expressions",
            "text": "JavaScript makes heavy use of anonymous function callbacks, which can be saved\nwithin JSON object variables. They only work if not returned inside double\nquotes, which zend-json implements by default. With the Expression support for\nzend-json, you can encode JSON objects with valid JavaScript callbacks.\nThis works when either  json_encode()  or the internal encoder is used.  A JavaScript callback is represented using the  Zend\\Json\\Expr  object. It\nimplements the value object pattern and is immutable. You can set the JavaScript\nexpression as the first constructor argument. By default Zend\\Json\\Json::encode()  does not encode JavaScript callbacks; you have to\npass the option  enableJsonExprFinder  and set it to  TRUE  when calling the encode()  method. If enabled, the expression support works for all nested\nexpressions in large object structures.  As an example:  $data = [\n    'onClick' => new Zend\\Json\\Expr(\n        'function() {'\n        . 'alert(\"I am a valid JavaScript callback created by Zend\\\\Json\");\n        . '}'\n    ),\n    'other' => 'no expression',\n];\n$jsonObjectWithExpression = Zend\\Json\\Json::encode(\n    $data,\n    false,\n    ['enableJsonExprFinder' => true]\n);",
            "title": "JSON Expressions"
        },
        {
            "location": "/migration/v2-to-v3/",
            "text": "Migrating from v2 to v3\n\n\nVersion 3 is the first significant departure in the zend-json API. In\nparticular, it features the removal of two features to new packages.\n\n\nzend-json-server\n\n\nThe \nZend\\Json\\Server\n subcomponent was extracted to a new component,\n\nzend-json-server\n. Install it\nusing:\n\n\n$ composer install zendframework/zend-json-server\n\n\n\nAll classes and functionality remain the same as in previous versions of\nzend-json.\n\n\nXML to JSON support\n\n\nv2 releases of zend-json provided \nZend\\Json\\Json::fromXml()\n, which could be\nused to convert an XML document to JSON. This functionality has been extracted\nto a new component, \nzend-xml2json\n.\nInstall it using:\n\n\n$ composer install zendframework/zend-xml2json\n\n\n\nIn order to use the functionality, you will need to modify your calls from\n\nZend\\Json\\Json::fromXml()\n to instead use \nZend\\Xml2Json\\Xml2Json::fromXml()\n.",
            "title": "From v2 to v3"
        },
        {
            "location": "/migration/v2-to-v3/#migrating-from-v2-to-v3",
            "text": "Version 3 is the first significant departure in the zend-json API. In\nparticular, it features the removal of two features to new packages.",
            "title": "Migrating from v2 to v3"
        },
        {
            "location": "/migration/v2-to-v3/#zend-json-server",
            "text": "The  Zend\\Json\\Server  subcomponent was extracted to a new component, zend-json-server . Install it\nusing:  $ composer install zendframework/zend-json-server  All classes and functionality remain the same as in previous versions of\nzend-json.",
            "title": "zend-json-server"
        },
        {
            "location": "/migration/v2-to-v3/#xml-to-json-support",
            "text": "v2 releases of zend-json provided  Zend\\Json\\Json::fromXml() , which could be\nused to convert an XML document to JSON. This functionality has been extracted\nto a new component,  zend-xml2json .\nInstall it using:  $ composer install zendframework/zend-xml2json  In order to use the functionality, you will need to modify your calls from Zend\\Json\\Json::fromXml()  to instead use  Zend\\Xml2Json\\Xml2Json::fromXml() .",
            "title": "XML to JSON support"
        }
    ]
}